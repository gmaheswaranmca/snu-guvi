"Coin Change", 
"Given coins of different denominations and a total amount, compute the fewest number of coins needed to make up that amount.", 
"Medium", 
"LeetCode, HackerRank"
"Amazon, Google, Apple"

---

Best Option:
- The Bottom-Up Dynamic Programming approach is the most reliable and efficient for this problem, given the constraints.

---

# Dynamic Programming (Bottom-Up, Tabulation)
def coin_change_bottom_up():
    n = int(input())
    coins = list(map(int, input().split()))
    amount = int(input())

    dp = [float('inf')] * (amount + 1)
    dp[0] = 0

    for i in range(1, amount + 1):
        for coin in coins:
            if i - coin >= 0:
                dp[i] = min(dp[i], dp[i - coin] + 1)

    print(dp[amount] if dp[amount] != float('inf') else -1)

# Uncomment below to run
# coin_change_bottom_up()

---

# Dynamic Programming (Top-Down, Memoization)
def coin_change_top_down():
    import sys
    sys.setrecursionlimit(10000)
    n = int(input())
    coins = list(map(int, input().split()))
    amount = int(input())

    from functools import lru_cache

    @lru_cache(maxsize=None)
    def dp(rem):
        if rem == 0:
            return 0
        if rem < 0:
            return float('inf')
        min_coins = float('inf')
        for coin in coins:
            res = dp(rem - coin)
            if res != float('inf'):
                min_coins = min(min_coins, res + 1)
        return min_coins

    ans = dp(amount)
    print(ans if ans != float('inf') else -1)

# Uncomment below to run
# coin_change_top_down()

---

# Breadth-First Search (BFS)
def coin_change_bfs():
    from collections import deque
    n = int(input())
    coins = list(map(int, input().split()))
    amount = int(input())

    if amount == 0:
        print(0)
        return

    visited = set()
    queue = deque()
    queue.append((0, 0))  # (current_amount, steps)

    while queue:
        curr, steps = queue.popleft()
        for coin in coins:
            next_amt = curr + coin
            if next_amt == amount:
                print(steps + 1)
                return
            if 0 <= next_amt <= amount and next_amt not in visited:
                visited.add(next_amt)
                queue.append((next_amt, steps + 1))
    print(-1)

# Uncomment below to run
# coin_change_bfs()

---

# Greedy (Not always correct for arbitrary denominations)
def coin_change_greedy():
    n = int(input())
    coins = list(map(int, input().split()))
    amount = int(input())

    coins.sort(reverse=True)
    count = 0
    for coin in coins:
        if amount >= coin:
            num = amount // coin
            count += num
            amount -= num * coin
    print(count if amount == 0 else -1)

# Uncomment below to run
# coin_change_greedy()

---

# MCQ Questions

# Question 1
Which of the following best describes the Coin Change problem?
A) Find the maximum number of coins needed to make a given amount  
B) Find the fewest number of coins needed to make a given amount  
C) Find all possible combinations of coins to make a given amount  
D) Find the largest coin denomination less than the amount  

# Question 2
Which algorithmic technique guarantees the correct answer for the Coin Change problem with arbitrary coin denominations?
A) Greedy  
B) Dynamic Programming (Bottom-Up)  
C) Depth-First Search  
D) Brute Force  

# Question 3
What is the time complexity of the Bottom-Up Dynamic Programming solution for the Coin Change problem?
A) O(n)  
B) O(amount)  
C) O(n * amount)  
D) O(n^2)  

# Question 4
Why does the greedy approach fail for some coin denominations in the Coin Change problem?
A) It always chooses the smallest coin  
B) It does not consider all combinations  
C) It only works for canonical coin systems  
D) Both B and C  

# Question 5
If the input coins are [1, 3, 4] and the amount is 6, what is the minimum number of coins needed?
A) 2  
B) 3  
C) 4  
D) 6  

# Question 6
Which data structure is most suitable for implementing the BFS approach in the Coin Change problem?
A) Stack  
B) Queue  
C) Priority Queue  
D) Linked List  

# Question 7
In the Top-Down DP approach, what is the main advantage of using memoization?
A) Reduces space complexity  
B) Avoids redundant calculations  
C) Increases recursion depth  
D) Makes the code more readable  

# Question 8
What should be returned if it is not possible to make up the amount with the given coins?
A) 0  
B) -1  
C) amount  
D) None  

---

# Answers
1. B  
2. B  
3. C  
4. D  
5. A  
6. B  
7. B  
8. B  

---