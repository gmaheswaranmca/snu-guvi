
Summary:
- The most efficient and standard solution is the greedy algorithm that sorts activities by end time and selects non-overlapping activities.
- Dynamic programming and brute force are not practical for this problem due to time complexity.

--- 

---

# Python solution using Greedy Algorithm (Earliest Finish Time First)

def max_activities(activities):
    # Sort activities by end time
    activities.sort(key=lambda x: x[1])
    count = 0
    last_end = -float('inf')
    for start, end in activities:
        if start >= last_end:
            count += 1
            last_end = end
    return count

if __name__ == "__main__":
    N = int(input())
    activities = [tuple(map(int, input().split())) for _ in range(N)]
    print(max_activities(activities))

---

# Python solution using Interval Scheduling Maximization (Classic Greedy)

def interval_scheduling_maximization(activities):
    # Sort activities by their end time
    activities.sort(key=lambda x: x[1])
    selected = []
    last_end = -float('inf')
    for start, end in activities:
        if start >= last_end:
            selected.append((start, end))
            last_end = end
    return len(selected)

if __name__ == "__main__":
    N = int(input())
    activities = [tuple(map(int, input().split())) for _ in range(N)]
    print(interval_scheduling_maximization(activities))

--- 

# Difference between Greedy Algorithm (Earliest Finish Time First) and Interval Scheduling Maximization (Classic Greedy):
    Both solutions in this file implement the same algorithm: sort activities by end time and select non-overlapping activities. The only difference is in variable naming and whether the selected activities are stored (in a list) or just counted.

    - The "Greedy Algorithm" version counts the number of selected activities.
    - The "Interval Scheduling Maximization" version builds a list of selected activities and returns its length.

    Algorithmically, both are identical and yield the same result for this problem.

# Python solution using Brute Force (Inefficient)

from itertools import combinations

def is_non_overlapping(subset):
    # Sort activities by start time
    subset = sorted(subset, key=lambda x: x[0])
    for i in range(1, len(subset)):
        if subset[i][0] < subset[i-1][1]:
            return False
    return True

def brute_force_max_activities(activities):
    n = len(activities)
    max_count = 0
    # Try all possible subsets
    for r in range(1, n+1):
        for subset in combinations(activities, r):
            if is_non_overlapping(subset):
                max_count = max(max_count, r)
    return max_count

if __name__ == "__main__":
    N = int(input())
    activities = [tuple(map(int, input().split())) for _ in range(N)]
    print(brute_force_max_activities(activities))

--- 