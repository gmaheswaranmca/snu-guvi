Today agenda: 
10 mins - to discuss LIS problem solutions [yesterday]
25 mins - to discuss qns and solutions techniques for today qns 
45 mins - to facilate to solve qns
40 mins - to discuss students solutions, complexity,  best solutions, related product based companies mcqs 

---

LIS input: 
10 9 2 5 3 7 101 18

I E    dp prev              dp 
0 10   1  -                 1
1 9    1  10F               1
2 2    1  10F 9F            1
3 5    1  10F 9F 2T         1 vs dp[2]+1=2
4 3    1  10F 9F 2T 5F      1 vs dp[2]+1=2
5 7    1  10F 9F 2T 5T 3T   1 vs dp[2]+1=2 vs dp[3]+1=3 vs dp[4]+1=3
6 101  1  10T 9T 2T 5T 3T 7T     1 vs dp[0]+1=2 vs dp[1]+1=2 vs dp[2]+1=3 vs dp[3]+1=3 vs dp[4]+1=3 vs dp[5]+1=4
7 18   1  10T 9T 2T 5T 3T 7T 101F 1 vs dp[0]+1=2 vs dp[1]+1=2 vs dp[2]+1=3 vs dp[3]+1=3 vs dp[4]+1=3 vs dp[5]+1=4

LIS len = 4


**Longest Increasing Subsequence (LIS)** 
using **custom binary search + patience sorting** technique:

ðŸ§ª Walkthrough With Example
Input:

```
arr = [10, 9, 2, 5, 3, 7, 101, 18]
```

We maintain:

* `tails[]` â€“ stores smallest ending value of subsequence of length `i+1`
* `size` â€“ length of longest subsequence found so far

---

Step-by-step

âž¤ num = 10

* Binary search in `[]`
* Insert at index 0
* `tails = [10]`, `size = 1`

âž¤ num = 9

* Binary search in `[10]`
* 9 < 10 â†’ replace index 0
* `tails = [9]`, `size = 1`

âž¤ num = 2

* Binary search in `[9]`
* 2 < 9 â†’ replace index 0
* `tails = [2]`, `size = 1`

âž¤ num = 5

* Binary search in `[2]`
* 5 > 2 â†’ insert at index 1
* `tails = [2, 5]`, `size = 2`

âž¤ num = 3

* Binary search in `[2, 5]`
* Replace 5 with 3
* `tails = [2, 3]`, `size = 2`

âž¤ num = 7

* Binary search in `[2, 3]`
* Append at index 2
* `tails = [2, 3, 7]`, `size = 3`

âž¤ num = 101

* Binary search in `[2, 3, 7]`
* Append at index 3
* `tails = [2, 3, 7, 101]`, `size = 4`

âž¤ num = 18

* Binary search in `[2, 3, 7, 101]`
* Replace 101 with 18
* `tails = [2, 3, 7, 18]`, `size = 4`

---

ðŸ§¾ Final Output

* The length of `tails[]` = `4` â†’ LIS length is **4**
* Actual LIS might be `[2, 3, 7, 18]` or `[2, 5, 7, 101]` etc.

---

ðŸ§  Key Concepts Recap

| Concept           | Explanation                                                |
| ----------------- | ---------------------------------------------------------- |
| `tails[i]`        | Smallest tail of an increasing subsequence of length `i+1` |
| Binary Search     | To find the correct pile to place the current number       |
| Replace vs Append | Replace to keep tails minimal; Append to grow subsequence  |
| `size`            | The final LIS length                                       |

---

# here arr[i] = [start[i],end[i]]
def max_non_overlaping_intervals(arr):
  arr.sort(key=lambda x: x[1])
  print(arr)
  i = 0
  ans = 1
  for j in range(1, len(arr)):
    if arr[i][1] <= arr[j][0]:
      ans += 1
      i = j
  return ans

1 3 
2 4       
3 5      
0 6     
5 7     
8 9  <- i       
            <- j
i=0 
j=1 2 3 4 5
ans = 4


def groupAnagrams(self, strs):
    """
    :type strs: List[str]
    :rtype: List[List[str]]
    """
    d={}
    for i in strs:
        temp = [0]*27
        for j in i:
            temp[ord(j)-ord('a')]+=1
        temp = tuple(temp)
        d[temp]=d.get(temp,[])+[i]
    return d.values()

int findKthLargest(vector<int>& nums, int k) {
        priority_queue<int, vector<int>, greater<int>> minHeap;
        minHeap.push(nums[0])
        for(int index = 1 ; index < nums.size() ; index++){

            minHeap.push(nums[index]); //max elemnt than the heap if size == k
            if(minHeap.size() > k){
                minHeap.pop();
            }

        }

        return minHeap.top();
    }

     if (minHeap.size() < k) {
                minHeap.push(num);
            } else if (num > minHeap.top() && minHeap.size() == k) {
                minHeap.pop();
                minHeap.push(num);
            }

solution accepted
--> edge case to be included 
78 77 76 75 74
k==2

78 77


int countFreq(vector<int>& arr, int target) {
        int n = arr.size();
        
        int firstOccurrence = -1;
        int lastOccurrence = -1;
        
        int left = 0, right = n - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            
            if (arr[mid] == target) {
                firstOccurrence = mid;
                right = mid - 1;

            }else if (arr[mid] < target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        
        if (firstOccurrence == -1) {
            return 0;
        }
        
        left = 0, right = n - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            
            if (arr[mid] == target) {
                lastOccurrence = mid;
                left = mid + 1;  
            } else if (arr[mid] < target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
return lastOccurrence - firstOccurrence + 1;
}
